<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>책 내용 정리: Clean Architecture | halimess 개발 블로그</title>
<meta name=keywords content="clean,architecture,book,clean architecture,pattern,SOLID,DI,Facade,Factory">
<meta name=description content="Clean Architecture 책에서 중요하다고 생각한 내용 정리">
<meta name=author content="halimess">
<link rel=canonical href=https://halimess.github.io/posts/cleanarchitecture/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.b15591da31b4f827d6dc0b97cf931d21b01610305321ac220bf755cf6aade94e.css integrity="sha256-sVWR2jG0+CfW3AuXz5MdIbAWEDBTIawiC/dVz2qt6U4=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://halimess.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://halimess.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://halimess.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://halimess.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://halimess.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-76JEWQFRMR"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-76JEWQFRMR',{anonymize_ip:!1})}</script>
<meta property="og:title" content="책 내용 정리: Clean Architecture">
<meta property="og:description" content="Clean Architecture 책에서 중요하다고 생각한 내용 정리">
<meta property="og:type" content="article">
<meta property="og:url" content="https://halimess.github.io/posts/cleanarchitecture/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-04-28T02:00:32+09:00">
<meta property="article:modified_time" content="2021-04-28T02:00:32+09:00"><meta property="og:site_name" content="아무 글">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="책 내용 정리: Clean Architecture">
<meta name=twitter:description content="Clean Architecture 책에서 중요하다고 생각한 내용 정리">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://halimess.github.io/posts/"},{"@type":"ListItem","position":2,"name":"책 내용 정리: Clean Architecture","item":"https://halimess.github.io/posts/cleanarchitecture/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"책 내용 정리: Clean Architecture","name":"책 내용 정리: Clean Architecture","description":"Clean Architecture 책에서 중요하다고 생각한 내용 정리","keywords":["clean","architecture","book","clean architecture","pattern","SOLID","DI","Facade","Factory"],"articleBody":"소개 1장. 설계와 아키텍처란? 설계랑 아키텍처는 같은 말이다.\n 아키텍처는 고수준의 무언가, 설계는 저수준의 구조 혹은 결정사항을 의미할 때가 많지만, 이러한 구분은 무의미 저수준의 세부사항과 고수준의 구조는 소프트웨어 전체 설계의 구성 요소 고수준 - 저수준으로 향하는 의사결정의 연속성만이 있을 뿐  소프트웨어 아키텍처의 목표  필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화 즉, 설계 품질의 척도는 요구 사항을 만족시키는 데 드는 비용을 재는 척도  엉망진창이 되어가는 신호  시스템을 급하게 만들거나 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나 코드와 설계의 구조를 깔끔하게 만들려는 생각을 전혀하지 않으면   파국이다…\n 빨리 가는 유일한 방법은 제대로 가는 것이다.\n2장. 두 가지 가치에 대한 이야기 소프트웨어 시스템의 두 가지 가치  행위 (behavior)  기계가 수익을 창출하거나 비용을 절약 개발자는  기능 명세서나 요구사항 문서를 구체화 코드를 작성 디버깅     구조 (structure)  기계의 행위를 쉽게 변경할 수 있도록 변경사항을 적용하는 데 어려움은  변경되는 범위(scope)에 비례 변경사항의 형태(shape)와는 관련이 없어야 한다      중요성과 긴급성 아이젠하워 매트릭스의 4 가지 유형\n 긴급하고 중요한 긴급하지는 않지만 중요한 긴급하지만 중요하지 않은 긴급하지도 중요하지도 않은   아키텍처는 1, 2 번에 해당 행위는 1, 3번에 해당   3번에 해당하는 행위를 첫 번째로 격상시키지 마라. 아키텍처가 후순위가 되면, 개발하는 비용이 증가하고 변경사항을 적용하는 일이 현실적으로 불가능해진다.\n기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 개발자 책임이다.\n  프로그래밍 패러다임 3장. 패러다임 개요 패러다임은 무엇을 해선 안되는지를 말한다.\n 구조적 프로그래밍 (structured programming)  goto문 ❌   객체 지향 프로그래밍 (object-oriented programming)  함수 포인터 ❌   함수형 프로그래밍 (functional programming)  할당문 ❌    세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)의 연관성에 주목하자\n4장. 구조적 프로그래밍 반증 가능한 단위로 기능적 분해하는 방법\n기능적 분해 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 모듈과 컴포넌트를 입증할 수 있는 아주 작은 기능들로 세분화 가능\nif/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조로 프로그래밍  goto문을 사용하면 모듈로 분해할 수 없는 경우가 발생 goto문을 사용하더라도 모듈로 분해할 수 있는 좋은 사용 방식은 분기와 반복의 단순한 제어 구조 대다수의 현대적 언어는 goto문을 포함하지 않음   데이크스트라는 프로그램 관점에서 유클리드 계층구조로 증명하려 했으나 끝내하지 못했다. 테스트로 프로그램의 동작을 증명할 순 없다. 다만 충분한 테스트로 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있을 뿐이다.\n 결론 모듈, 컴포넌트, 서비스를 쉽게 테스트할 수 있도록 해야 한다.\n5장. 객체 지향 프로그래밍 객체 지향의 3가지 개념? 캡슐화? (encapsulation)  객체 지향에만 국한된 건 아니다 C 프로그램의 헤더 파일을 제공하는 것으로 캡슐화된다. C++ 컴파일러는 클래스의 멤버 변수를 해당 클래스의 헤더파일에 선언해야 한다.  완전한 캡슐화가 깨짐   C++ 컴파일러는 클래스의 인스턴스 크기를 알 수 있어야 한다.\n  객체 지향 프로그래밍은 개발자가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거란 믿음을 기반한다. 실제로 객체 지향을 제공한다는 언어들은 C 언어에서 누렸던 완벽한 캡슐화를 약화시켰다.  상속? (inheritance)  객체 지향 언어가 확실히 제공했다. 상속은 단순히 어떤 변수, 함수를 하나의 유효 범위로 묶어서 재정의하는 일 이전에도 있었던 기법이나, 객체 지향 언어는 상속을 편리한 방식으로 제공  다형성? (polymorphism)  전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력 플러그인 아키텍처를 구성할 수 있다.  장치 독립적인 아키텍처 예시) 유닉스 운영 체제의 입출력 장치 드라이버  다섯 가지 표준 함수를 제공 open, close, read, write, seek   FILE 데이터 구조는 이들 다섯 함수를 가리키는 포인터를 포함한다.\n    함수 포인터의 위험성  포인터를 초기화하는 관례를 준수해야 한다 개발자가 이를 망각하면 버그가 발생하며, 이 경우 디버깅이 매우 힘들다   객체 지향 언어는 이러한 관례를 없애준다. 소스 코드 의존성은 인터페이스를 추가하여 의존성 역전시킬 수 있다  배포 독립성, 개발 독립성 확보     고수준 정책을 포함하는 모듈과 저수준의 세부사항을 포함하는 모듈의 독립성 보장\n 6장. 함수형 프로그래밍 가변 변수가 없기 때문에 동시성 애플리케이션에 마주치는 모든 문제가 생기지 않는다.\n race, deadlock, concurrent update 문제\n 가변성 분리 가변 컴포넌트와 불변(순수 함수형) 컴포넌트를 분리해야 한다\n 불변 컴포넌트를 가변 컴포넌트와 통신하게 하고, 가변 컴포넌트의 상태 변경은 트랜잭션, 재시도 등의 방법으로 concurrent update / race 문제를 예방한다. 가능한 한 많은 처리는 불변 컴포넌트로 옮기고, 가변 컴포넌트에는 가능한 한 많은 코드를 빼내야 한다.  이벤트 소싱  상태 변경이 아닌 트랜잭션을 저장 CRUD가 아닌 CR만 수행하여, 동시 업데이트 문제가 발생하지 않는다. 저장 공간이 많이 필요하다 - 이젠 이러한 저장 공간은 충분히 확보할 수 있다. git과 같은 VCS가 한 예시   설계 원칙 S.O.L.I.D\n 변경에 유연 / 이해하기 쉽게 / 컴포넌트의 기반\n 7장. SRP: 단일 책임 원칙 (Single Responsibility Principle) 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.\n 서로 다른 액터(소프트웨어 사용자)가 의존하는 코드를 서로 분리 데이터와 메서드를 분리 - 퍼사드 (Facade) 패턴  8장. OCP: 개방-폐쇄 원칙 (Open-Closed Principle) 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 설계\n 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 컴포넌트 단위로 분리 저수준 컴포넌트에서 발생한 변경이 고수준 컴포넌트에 영향을 끼쳐선 안된다  9장. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle) 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들어라\n 하위 타입은 상위 타입과 서로 치환 가능해야 한다\n  아키텍처 수준으로 확장해야 한다  치환 가능성을 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 한다.    10장. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle) 사용하지 않는 것에 의존하지 않아야 한다.\n 언어 종류에 따라 영향받는 정도가 다르다 필요한 것에만 의존하여 한 컴포넌트의 변경으로 다른 컴포넌트의 재컴파일과 재배포를 하지 않도록 한다.  11장. DIP: 의존성 역전 원칙 (Dependency Inversion Principle) 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다.\n 세부사항이 정책에 의존해야 한다.\n  유연성이 극대화된 시스템으로 소크 코드 의존성이 추상(abstraction)에 의존 변동성이 큰 구체적인 요소에 의존하지 않도록 설계  운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 의존하여도 용납\n  인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 설계 의존성 역전을 위해 추상 팩토리를 사용하곤 한다.   컴포넌트 원칙 12장. 컴포넌트 컴포넌트는 배포 단위로, 자바의 경우 jar 파일이 컴포넌트이다. 잘 설계된 컴포넌트는 독립적으로 배포 가능하며 독립적으로 개발 가능해야 한다.\n컴포넌트 플러그인 아키텍처\n13장. 컴포넌트 응집도  REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)  소프트웨어 재사용 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스하며 버전 번호가 같아야 한다   CCP: 공통 폐쇄 원칙 (Common Closure Principle) CRP: 공통 재사용 원칙 (Common Reuse Principle)  TBU\n","wordCount":"922","inLanguage":"en","datePublished":"2021-04-28T02:00:32+09:00","dateModified":"2021-04-28T02:00:32+09:00","author":{"@type":"Person","name":"halimess"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://halimess.github.io/posts/cleanarchitecture/"},"publisher":{"@type":"Organization","name":"halimess 개발 블로그","logo":{"@type":"ImageObject","url":"https://halimess.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://halimess.github.io/ accesskey=h title="halimess (Alt + H)">halimess</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://halimess.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://halimess.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://halimess.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://halimess.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://halimess.github.io/posts/>Posts</a></div>
<h1 class=post-title>
책 내용 정리: Clean Architecture
</h1>
<div class=post-description>
Clean Architecture 책에서 중요하다고 생각한 내용 정리
</div>
<div class=post-meta>April 28, 2021&nbsp;·&nbsp;5 min&nbsp;·&nbsp;halimess
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div>
</summary>
<div class=inner><ul>
<li>
<a href=#%ec%86%8c%ea%b0%9c aria-label=소개>소개</a><ul>
<li>
<a href=#1%ec%9e%a5-%ec%84%a4%ea%b3%84%ec%99%80-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%eb%9e%80 aria-label="1장. 설계와 아키텍처란?">1장. 설계와 아키텍처란?</a><ul>
<li>
<a href=#%ec%86%8c%ed%94%84%ed%8a%b8%ec%9b%a8%ec%96%b4-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%ec%9d%98-%eb%aa%a9%ed%91%9c aria-label="소프트웨어 아키텍처의 목표">소프트웨어 아키텍처의 목표</a><ul>
<li>
<a href=#%ec%97%89%eb%a7%9d%ec%a7%84%ec%b0%bd%ec%9d%b4-%eb%90%98%ec%96%b4%ea%b0%80%eb%8a%94-%ec%8b%a0%ed%98%b8 aria-label="엉망진창이 되어가는 신호">엉망진창이 되어가는 신호</a></li></ul>
</li></ul>
</li>
<li>
<a href=#2%ec%9e%a5-%eb%91%90-%ea%b0%80%ec%a7%80-%ea%b0%80%ec%b9%98%ec%97%90-%eb%8c%80%ed%95%9c-%ec%9d%b4%ec%95%bc%ea%b8%b0 aria-label="2장. 두 가지 가치에 대한 이야기">2장. 두 가지 가치에 대한 이야기</a><ul>
<li>
<a href=#%ec%86%8c%ed%94%84%ed%8a%b8%ec%9b%a8%ec%96%b4-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%98-%eb%91%90-%ea%b0%80%ec%a7%80-%ea%b0%80%ec%b9%98 aria-label="소프트웨어 시스템의 두 가지 가치">소프트웨어 시스템의 두 가지 가치</a></li>
<li>
<a href=#%ec%a4%91%ec%9a%94%ec%84%b1%ea%b3%bc-%ea%b8%b4%ea%b8%89%ec%84%b1 aria-label="중요성과 긴급성">중요성과 긴급성</a></li></ul>
</li></ul>
</li>
<li>
<a href=#%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84 aria-label="프로그래밍 패러다임">프로그래밍 패러다임</a><ul>
<li>
<a href=#3%ec%9e%a5-%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84-%ea%b0%9c%ec%9a%94 aria-label="3장. 패러다임 개요">3장. 패러다임 개요</a></li>
<li>
<a href=#4%ec%9e%a5-%ea%b5%ac%ec%a1%b0%ec%a0%81-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d aria-label="4장. 구조적 프로그래밍">4장. 구조적 프로그래밍</a><ul>
<li>
<a href=#%ea%b8%b0%eb%8a%a5%ec%a0%81-%eb%b6%84%ed%95%b4 aria-label="기능적 분해">기능적 분해</a><ul>
<li>
<a href=#ifthenelse%ec%99%80-dowhile%ea%b3%bc-%ea%b0%99%ec%9d%80-%eb%b6%84%ea%b8%b0%ec%99%80-%eb%b0%98%eb%b3%b5%ec%9d%b4%eb%9d%bc%eb%8a%94-%eb%8b%a8%ec%88%9c%ed%95%9c-%ec%a0%9c%ec%96%b4-%ea%b5%ac%ec%a1%b0%eb%a1%9c-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d aria-label="if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조로 프로그래밍">if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조로 프로그래밍</a></li></ul>
</li>
<li>
<a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li></ul>
</li>
<li>
<a href=#5%ec%9e%a5-%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d aria-label="5장. 객체 지향 프로그래밍">5장. 객체 지향 프로그래밍</a><ul>
<li>
<a href=#%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5%ec%9d%98-3%ea%b0%80%ec%a7%80-%ea%b0%9c%eb%85%90 aria-label="객체 지향의 3가지 개념?">객체 지향의 3가지 개념?</a><ul>
<li>
<a href=#%ec%ba%a1%ec%8a%90%ed%99%94-encapsulation aria-label="캡슐화? (encapsulation)">캡슐화? (encapsulation)</a></li>
<li>
<a href=#%ec%83%81%ec%86%8d-inheritance aria-label="상속? (inheritance)">상속? (inheritance)</a></li>
<li>
<a href=#%eb%8b%a4%ed%98%95%ec%84%b1-polymorphism aria-label="다형성? (polymorphism)">다형성? (polymorphism)</a></li></ul>
</li>
<li>
<a href=#6%ec%9e%a5-%ed%95%a8%ec%88%98%ed%98%95-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d aria-label="6장. 함수형 프로그래밍">6장. 함수형 프로그래밍</a><ul>
<li>
<a href=#%ea%b0%80%eb%b3%80%ec%84%b1-%eb%b6%84%eb%a6%ac aria-label="가변성 분리">가변성 분리</a></li>
<li>
<a href=#%ec%9d%b4%eb%b2%a4%ed%8a%b8-%ec%86%8c%ec%8b%b1 aria-label="이벤트 소싱">이벤트 소싱</a></li></ul>
</li></ul>
</li></ul>
</li>
<li>
<a href=#%ec%84%a4%ea%b3%84-%ec%9b%90%ec%b9%99 aria-label="설계 원칙">설계 원칙</a><ul>
<li>
<a href=#7%ec%9e%a5-srp-%eb%8b%a8%ec%9d%bc-%ec%b1%85%ec%9e%84-%ec%9b%90%ec%b9%99-single-responsibility-principle aria-label="7장. SRP: 단일 책임 원칙 (Single Responsibility Principle)">7장. SRP: 단일 책임 원칙 (Single Responsibility Principle)</a></li>
<li>
<a href=#8%ec%9e%a5-ocp-%ea%b0%9c%eb%b0%a9-%ed%8f%90%ec%87%84-%ec%9b%90%ec%b9%99-open-closed-principle aria-label="8장. OCP: 개방-폐쇄 원칙 (Open-Closed Principle)">8장. OCP: 개방-폐쇄 원칙 (Open-Closed Principle)</a></li>
<li>
<a href=#9%ec%9e%a5-lsp-%eb%a6%ac%ec%8a%a4%ec%bd%94%ed%94%84-%ec%b9%98%ed%99%98-%ec%9b%90%ec%b9%99-liskov-substitution-principle aria-label="9장. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)">9장. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)</a></li>
<li>
<a href=#10%ec%9e%a5-isp-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4-%eb%b6%84%eb%a6%ac-%ec%9b%90%ec%b9%99-interface-segregation-principle aria-label="10장. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)">10장. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)</a></li>
<li>
<a href=#11%ec%9e%a5-dip-%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%97%ad%ec%a0%84-%ec%9b%90%ec%b9%99-dependency-inversion-principle aria-label="11장. DIP: 의존성 역전 원칙 (Dependency Inversion Principle)">11장. DIP: 의존성 역전 원칙 (Dependency Inversion Principle)</a></li></ul>
</li>
<li>
<a href=#%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8-%ec%9b%90%ec%b9%99 aria-label="컴포넌트 원칙">컴포넌트 원칙</a><ul>
<li>
<a href=#12%ec%9e%a5-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8 aria-label="12장. 컴포넌트">12장. 컴포넌트</a></li>
<li>
<a href=#13%ec%9e%a5-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8-%ec%9d%91%ec%a7%91%eb%8f%84 aria-label="13장. 컴포넌트 응집도">13장. 컴포넌트 응집도</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=소개>소개<a hidden class=anchor aria-hidden=true href=#소개>#</a></h1>
<h2 id=1장-설계와-아키텍처란>1장. 설계와 아키텍처란?<a hidden class=anchor aria-hidden=true href=#1장-설계와-아키텍처란>#</a></h2>
<p>설계랑 아키텍처는 같은 말이다.</p>
<ul>
<li>아키텍처는 고수준의 무언가, 설계는 저수준의 구조 혹은 결정사항을 의미할 때가 많지만, 이러한 구분은 무의미</li>
<li>저수준의 세부사항과 고수준의 구조는 소프트웨어 전체 설계의 구성 요소</li>
<li>고수준 -> 저수준으로 향하는 의사결정의 연속성만이 있을 뿐</li>
</ul>
<h3 id=소프트웨어-아키텍처의-목표>소프트웨어 아키텍처의 목표<a hidden class=anchor aria-hidden=true href=#소프트웨어-아키텍처의-목표>#</a></h3>
<ul>
<li>필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화</li>
<li>즉, 설계 품질의 척도는 요구 사항을 만족시키는 데 드는 비용을 재는 척도</li>
</ul>
<h4 id=엉망진창이-되어가는-신호>엉망진창이 되어가는 신호<a hidden class=anchor aria-hidden=true href=#엉망진창이-되어가는-신호>#</a></h4>
<ol>
<li>시스템을 급하게 만들거나</li>
<li>결과물의 총량을 순전히 프로그래머 수만으로 결정하거나</li>
<li>코드와 설계의 구조를 깔끔하게 만들려는 생각을 전혀하지 않으면</li>
</ol>
<blockquote>
<p>파국이다&mldr;</p>
</blockquote>
<p><strong>빨리 가는 유일한 방법은 제대로 가는 것이다.</strong></p>
<h2 id=2장-두-가지-가치에-대한-이야기>2장. 두 가지 가치에 대한 이야기<a hidden class=anchor aria-hidden=true href=#2장-두-가지-가치에-대한-이야기>#</a></h2>
<h3 id=소프트웨어-시스템의-두-가지-가치>소프트웨어 시스템의 두 가지 가치<a hidden class=anchor aria-hidden=true href=#소프트웨어-시스템의-두-가지-가치>#</a></h3>
<ol>
<li>행위 (behavior)
<ul>
<li>기계가 수익을 창출하거나 비용을 절약</li>
<li>개발자는
<ul>
<li>기능 명세서나 요구사항 문서를 구체화</li>
<li>코드를 작성</li>
<li>디버깅</li>
</ul>
</li>
</ul>
</li>
<li>구조 (structure)
<ul>
<li>기계의 행위를 쉽게 변경할 수 있도록</li>
<li>변경사항을 적용하는 데 어려움은
<ul>
<li>변경되는 범위(scope)에 비례</li>
<li>변경사항의 형태(shape)와는 관련이 없어야 한다</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id=중요성과-긴급성>중요성과 긴급성<a hidden class=anchor aria-hidden=true href=#중요성과-긴급성>#</a></h3>
<p>아이젠하워 매트릭스의 4 가지 유형</p>
<ol>
<li>긴급하고 중요한</li>
<li>긴급하지는 않지만 중요한</li>
<li>긴급하지만 중요하지 않은</li>
<li>긴급하지도 중요하지도 않은</li>
</ol>
<ul>
<li>아키텍처는 1, 2 번에 해당</li>
<li>행위는 1, 3번에 해당</li>
</ul>
<blockquote>
<p>3번에 해당하는 행위를 첫 번째로 격상시키지 마라.
아키텍처가 후순위가 되면, 개발하는 비용이 증가하고 변경사항을 적용하는 일이 현실적으로 불가능해진다.</p>
<p><strong>기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 개발자 책임이다.</strong></p>
</blockquote>
<hr>
<h1 id=프로그래밍-패러다임>프로그래밍 패러다임<a hidden class=anchor aria-hidden=true href=#프로그래밍-패러다임>#</a></h1>
<h2 id=3장-패러다임-개요>3장. 패러다임 개요<a hidden class=anchor aria-hidden=true href=#3장-패러다임-개요>#</a></h2>
<p>패러다임은 무엇을 해선 안되는지를 말한다.</p>
<ul>
<li>구조적 프로그래밍 (structured programming)
<ul>
<li>goto문 ❌</li>
</ul>
</li>
<li>객체 지향 프로그래밍 (object-oriented programming)
<ul>
<li>함수 포인터 ❌</li>
</ul>
</li>
<li>함수형 프로그래밍 (functional programming)
<ul>
<li>할당문 ❌</li>
</ul>
</li>
</ul>
<p><em>세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)의 연관성에 주목하자</em></p>
<h2 id=4장-구조적-프로그래밍>4장. 구조적 프로그래밍<a hidden class=anchor aria-hidden=true href=#4장-구조적-프로그래밍>#</a></h2>
<p>반증 가능한 단위로 기능적 분해하는 방법</p>
<h3 id=기능적-분해>기능적 분해<a hidden class=anchor aria-hidden=true href=#기능적-분해>#</a></h3>
<p>대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 모듈과 컴포넌트를 입증할 수 있는 아주 작은 기능들로 세분화 가능</p>
<h4 id=ifthenelse와-dowhile과-같은-분기와-반복이라는-단순한-제어-구조로-프로그래밍>if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조로 프로그래밍<a hidden class=anchor aria-hidden=true href=#ifthenelse와-dowhile과-같은-분기와-반복이라는-단순한-제어-구조로-프로그래밍>#</a></h4>
<ul>
<li>goto문을 사용하면 모듈로 분해할 수 없는 경우가 발생</li>
<li>goto문을 사용하더라도 모듈로 분해할 수 있는 좋은 사용 방식은 분기와 반복의 단순한 제어 구조</li>
<li>대다수의 현대적 언어는 goto문을 포함하지 않음</li>
</ul>
<blockquote>
<p>데이크스트라는 프로그램 관점에서 유클리드 계층구조로 증명하려 했으나 끝내하지 못했다.
<code>테스트</code>로 프로그램의 동작을 증명할 순 없다.
다만 충분한 테스트로 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있을 뿐이다.</p>
</blockquote>
<h3 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h3>
<p>모듈, 컴포넌트, 서비스를 쉽게 테스트할 수 있도록 해야 한다.</p>
<h2 id=5장-객체-지향-프로그래밍>5장. 객체 지향 프로그래밍<a hidden class=anchor aria-hidden=true href=#5장-객체-지향-프로그래밍>#</a></h2>
<h3 id=객체-지향의-3가지-개념>객체 지향의 3가지 개념?<a hidden class=anchor aria-hidden=true href=#객체-지향의-3가지-개념>#</a></h3>
<h4 id=캡슐화-encapsulation>캡슐화? (encapsulation)<a hidden class=anchor aria-hidden=true href=#캡슐화-encapsulation>#</a></h4>
<ul>
<li>객체 지향에만 국한된 건 아니다</li>
<li>C 프로그램의 헤더 파일을 제공하는 것으로 캡슐화된다.</li>
<li>C++ 컴파일러는 클래스의 멤버 변수를 해당 클래스의 헤더파일에 선언해야 한다.
<ul>
<li>완전한 캡슐화가 깨짐</li>
</ul>
<blockquote>
<p>C++ 컴파일러는 클래스의 인스턴스 크기를 알 수 있어야 한다.</p>
</blockquote>
</li>
<li>객체 지향 프로그래밍은 개발자가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거란 믿음을 기반한다.</li>
<li>실제로 객체 지향을 제공한다는 언어들은 C 언어에서 누렸던 완벽한 캡슐화를 약화시켰다.</li>
</ul>
<h4 id=상속-inheritance>상속? (inheritance)<a hidden class=anchor aria-hidden=true href=#상속-inheritance>#</a></h4>
<ul>
<li>객체 지향 언어가 확실히 제공했다.</li>
<li>상속은 단순히 어떤 변수, 함수를 하나의 유효 범위로 묶어서 재정의하는 일</li>
<li>이전에도 있었던 기법이나, 객체 지향 언어는 상속을 편리한 방식으로 제공</li>
</ul>
<h4 id=다형성-polymorphism>다형성? (polymorphism)<a hidden class=anchor aria-hidden=true href=#다형성-polymorphism>#</a></h4>
<ul>
<li>전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력</li>
<li>플러그인 아키텍처를 구성할 수 있다.
<ul>
<li>장치 독립적인 아키텍처</li>
<li>예시) 유닉스 운영 체제의 입출력 장치 드라이버
<ul>
<li>다섯 가지 표준 함수를 제공</li>
<li>open, close, read, write, seek</li>
</ul>
<blockquote>
<p>FILE 데이터 구조는 이들 다섯 함수를 가리키는 포인터를 포함한다.</p>
</blockquote>
</li>
</ul>
</li>
<li>함수 포인터의 위험성
<ul>
<li>포인터를 초기화하는 관례를 준수해야 한다</li>
<li>개발자가 이를 망각하면 버그가 발생하며, 이 경우 디버깅이 매우 힘들다</li>
</ul>
</li>
<li>객체 지향 언어는 이러한 관례를 없애준다.</li>
<li>소스 코드 의존성은 인터페이스를 추가하여 의존성 역전시킬 수 있다
<ul>
<li>배포 독립성, 개발 독립성 확보</li>
</ul>
</li>
</ul>
<blockquote>
<p>고수준 정책을 포함하는 모듈과 저수준의 세부사항을 포함하는 모듈의 독립성 보장</p>
</blockquote>
<h3 id=6장-함수형-프로그래밍>6장. 함수형 프로그래밍<a hidden class=anchor aria-hidden=true href=#6장-함수형-프로그래밍>#</a></h3>
<p>가변 변수가 없기 때문에 동시성 애플리케이션에 마주치는 모든 문제가 생기지 않는다.</p>
<blockquote>
<p>race, deadlock, concurrent update 문제</p>
</blockquote>
<h4 id=가변성-분리>가변성 분리<a hidden class=anchor aria-hidden=true href=#가변성-분리>#</a></h4>
<p>가변 컴포넌트와 불변(순수 함수형) 컴포넌트를 분리해야 한다</p>
<ul>
<li>불변 컴포넌트를 가변 컴포넌트와 통신하게 하고,</li>
<li>가변 컴포넌트의 상태 변경은 트랜잭션, 재시도 등의 방법으로 concurrent update / race 문제를 예방한다.</li>
<li>가능한 한 많은 처리는 불변 컴포넌트로 옮기고, 가변 컴포넌트에는 가능한 한 많은 코드를 빼내야 한다.</li>
</ul>
<h4 id=이벤트-소싱>이벤트 소싱<a hidden class=anchor aria-hidden=true href=#이벤트-소싱>#</a></h4>
<ul>
<li>상태 변경이 아닌 트랜잭션을 저장</li>
<li>CRUD가 아닌 CR만 수행하여, 동시 업데이트 문제가 발생하지 않는다.</li>
<li>저장 공간이 많이 필요하다 -> 이젠 이러한 저장 공간은 충분히 확보할 수 있다.</li>
<li>git과 같은 VCS가 한 예시</li>
</ul>
<hr>
<h1 id=설계-원칙>설계 원칙<a hidden class=anchor aria-hidden=true href=#설계-원칙>#</a></h1>
<p>S.O.L.I.D</p>
<blockquote>
<p>변경에 유연 / 이해하기 쉽게 / 컴포넌트의 기반</p>
</blockquote>
<h2 id=7장-srp-단일-책임-원칙-single-responsibility-principle>7장. SRP: 단일 책임 원칙 (Single Responsibility Principle)<a hidden class=anchor aria-hidden=true href=#7장-srp-단일-책임-원칙-single-responsibility-principle>#</a></h2>
<p>각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.</p>
<ul>
<li>서로 다른 액터(소프트웨어 사용자)가 의존하는 코드를 서로 분리</li>
<li>데이터와 메서드를 분리 -> <a href=?>퍼사드 (Facade) 패턴</a></li>
</ul>
<h2 id=8장-ocp-개방-폐쇄-원칙-open-closed-principle>8장. OCP: 개방-폐쇄 원칙 (Open-Closed Principle)<a hidden class=anchor aria-hidden=true href=#8장-ocp-개방-폐쇄-원칙-open-closed-principle>#</a></h2>
<p>기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 설계</p>
<ul>
<li>확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록</li>
<li>컴포넌트 단위로 분리</li>
<li>저수준 컴포넌트에서 발생한 변경이 고수준 컴포넌트에 영향을 끼쳐선 안된다</li>
</ul>
<h2 id=9장-lsp-리스코프-치환-원칙-liskov-substitution-principle>9장. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)<a hidden class=anchor aria-hidden=true href=#9장-lsp-리스코프-치환-원칙-liskov-substitution-principle>#</a></h2>
<p>상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들어라</p>
<blockquote>
<p>하위 타입은 상위 타입과 서로 치환 가능해야 한다</p>
</blockquote>
<ul>
<li>아키텍처 수준으로 확장해야 한다
<ul>
<li>치환 가능성을 위배하면 시스템 아키텍처가 오염되어 <code>상당량의 별도 메커니즘을 추가해야</code> 한다.</li>
</ul>
</li>
</ul>
<h2 id=10장-isp-인터페이스-분리-원칙-interface-segregation-principle>10장. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)<a hidden class=anchor aria-hidden=true href=#10장-isp-인터페이스-분리-원칙-interface-segregation-principle>#</a></h2>
<p>사용하지 않는 것에 의존하지 않아야 한다.</p>
<ul>
<li>언어 종류에 따라 영향받는 정도가 다르다</li>
<li>필요한 것에만 의존하여 한 컴포넌트의 변경으로 다른 컴포넌트의 재컴파일과 재배포를 하지 않도록 한다.</li>
</ul>
<h2 id=11장-dip-의존성-역전-원칙-dependency-inversion-principle>11장. DIP: 의존성 역전 원칙 (Dependency Inversion Principle)<a hidden class=anchor aria-hidden=true href=#11장-dip-의존성-역전-원칙-dependency-inversion-principle>#</a></h2>
<p>고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다.</p>
<blockquote>
<p>세부사항이 정책에 의존해야 한다.</p>
</blockquote>
<ul>
<li>유연성이 극대화된 시스템으로 소크 코드 의존성이 추상(abstraction)에 의존</li>
<li>변동성이 큰 구체적인 요소에 의존하지 않도록 설계
<blockquote>
<p>운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 의존하여도 용납</p>
</blockquote>
</li>
<li>인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 설계</li>
<li>의존성 역전을 위해 <a href=?>추상 팩토리</a>를 사용하곤 한다.</li>
</ul>
<hr>
<h1 id=컴포넌트-원칙>컴포넌트 원칙<a hidden class=anchor aria-hidden=true href=#컴포넌트-원칙>#</a></h1>
<h2 id=12장-컴포넌트>12장. 컴포넌트<a hidden class=anchor aria-hidden=true href=#12장-컴포넌트>#</a></h2>
<p>컴포넌트는 배포 단위로, 자바의 경우 jar 파일이 컴포넌트이다.
잘 설계된 컴포넌트는 <code>독립적으로 배포 가능하며 독립적으로 개발 가능</code>해야 한다.</p>
<p>컴포넌트 플러그인 아키텍처</p>
<h2 id=13장-컴포넌트-응집도>13장. 컴포넌트 응집도<a hidden class=anchor aria-hidden=true href=#13장-컴포넌트-응집도>#</a></h2>
<ul>
<li>REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
<ul>
<li>소프트웨어 재사용</li>
<li>컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함</li>
<li>하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스하며 버전 번호가 같아야 한다</li>
</ul>
</li>
<li>CCP: 공통 폐쇄 원칙 (Common Closure Principle)</li>
<li>CRP: 공통 재사용 원칙 (Common Reuse Principle)</li>
</ul>
<p><strong>TBU</strong></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://halimess.github.io/tags/clean/>clean</a></li>
<li><a href=https://halimess.github.io/tags/architecture/>architecture</a></li>
<li><a href=https://halimess.github.io/tags/book/>book</a></li>
<li><a href=https://halimess.github.io/tags/clean-architecture/>clean architecture</a></li>
<li><a href=https://halimess.github.io/tags/pattern/>pattern</a></li>
<li><a href=https://halimess.github.io/tags/solid/>SOLID</a></li>
<li><a href=https://halimess.github.io/tags/di/>DI</a></li>
<li><a href=https://halimess.github.io/tags/facade/>Facade</a></li>
<li><a href=https://halimess.github.io/tags/factory/>Factory</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://halimess.github.io/posts/aws/vpc/>
<span class=title>« Prev Page</span>
<br>
<span>AWS VPC 이론 공부</span>
</a>
<a class=next href=https://halimess.github.io/posts/firstpage/>
<span class=title>Next Page »</span>
<br>
<span>개발 블로그 시작</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://halimess.github.io/>halimess 개발 블로그</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const d=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function c(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),c();return}const a=document.createRange();a.selectNodeContents(b);const d=window.getSelection();d.removeAllRanges(),d.addRange(a);try{document.execCommand('copy'),c()}catch(a){}d.removeRange(a)}),d.appendChild(a)})</script>
</body>
</html>