[{"content":" 레퍼런스: DevOpsArt 신입 or Jr 엔지니어 면접을 위한 리눅스 명령어 top 10\n   Server를 어떻게 접속하나요?\n특별히 사용하는 도구나 방법이 있을까요?\n 다양한 방법이 있겠지만, 여기선 ssh만 설명 ssh란 secure shell의 약자로 클라이언트와 서버 간의 보안 상 안전한 연결을 위한 암호화 프로토콜  예시: aws ec2 생성 시 private key를 설정하여 서버 접근 시 활용  ssh -i \u0026#34;/pwd/private-key.pem\u0026#34; user@server.host # private key 활용  기본 ssh 포트는 22 ssh 포트 변경 시 /etc/ssh/sshd_config의 설정을 변경해주자 ssh-agent, ssh-add 명령어로 ssh-agent에 private key를 저장하여 활용 가능  private key를 직접 입력하지 않고 서버 접속을 가능케 함        ssh academy\n  IP를 확인하는 리눅스 명령어는 무엇인가요?\n자신의 Public IP는 어떻게 확인하나요?\n ifconfig Private IP가 조회될 수 있음 curl icanhazip.com curl ifconfig.co curl ifconfig.me    웹사이트가 잘 동작하는지 체크할 때 사용하는 명령어는?\ncurl을 사용해본적은 있는지?\n사용해보았다면 주로 어떨 때 사용하는지?\n curl google.com   google.com 도메인에 연결된 서버에서 301 Moved 응답을 내려준 것을 확인할 수 있음 브라우저는 301 Moved 응답에서 지정된 링크로 이동할 것임   curl -v google.com   어떻게 request했는 지, 어떤 response header를 받았는 지 확인할 수 있음   curl -v https://google.com   https 프로토콜에 대한 ssl 인증서 확인 가능      Domain의 IP를 조회하는 명령어는?\n nslookup  더 이상 maintain되진 않는다고 함   dig  DNS 진단에 활용   host  간단히 DNS 확인 시 유용       nslookup\nnslookup vs dig and host\nwhy nslookup is deprecated\n  웹서버 혹은 DB 같은 서버들을 확인하는 방법은?\n telnet host port     nc ping  ICMP 프로토콜로 특정 IP와의 연결을 테스트 특정 TCP 포트를 통한 연결을 테스트하긴 어렵다      내 서버의 서버(웹 어플리케이션 or DB)가 잘 떠있는지,\n현재 DB 커넥션 등을 확인하는 명령어는?\n netstat -lntp  ec2 인스턴스에 tomcat을 띄우고 8080 포트로 tomcat이 뜬 것을 확인할 수 있음    Linux에서 특정 프로세스를 확인하는 명령어는?\nprocess id, option 등을 확인하고 싶다면?\n ps -ef | grep ssh  TODO: ps 자주 사용하는 옵션 내용 정리    Linux에서 CPU, Memory, Disk 등 시스템 정보 등을 확인하는 명령어들은?\n top  현재 프로세스, cpu/memory 사용량 확인   sar 1  1초마다 cpu 상태 출력   free -m  메모리 사용량 /proc/meminfo   df  디스크 확인   iostat    Linux에서 서비스들은 어떻게 관리되고, 그와 연관된 명려어는?\n yum, apt 등으로 설치하면 자동으로 system 파일을 생성해주기 때문에 모르고 넘어가는 경우가 많음 /etc/systemd/system 참고 service tomcat status     Linux 파일 권한 체계를 이해하고 있는지?\n chmod  read = 4 write = 2 execute = 1 chmod 400 : owner-r, group-, other- chmod 755 : owner-rwx, group-rx, other-rx   chown  chown owner[:group]       그 밖에도 많은 명령어가 있습니다.\n cd, cp, mv, ls 같은 명령어는 당연히 알아야하는 명령어입니다. 리눅스의 부팅 프로세스를 알고 있는지에 대한 질문도 하는 경우가 있습니다.(/etc/profile. /etc/rc*, cloud-init 등 그 이후 cron 등) fdisk, lvm, mkfs 등 파일 시스템 관련 yum, apt 등 repo 관련한    ","permalink":"https://halimess.github.io/posts/linux/mustknowcommand/","summary":"레퍼런스: DevOpsArt 신입 or Jr 엔지니어 면접을 위한 리눅스 명령어 top 10\n   Server를 어떻게 접속하나요?\n특별히 사용하는 도구나 방법이 있을까요?\n 다양한 방법이 있겠지만, 여기선 ssh만 설명 ssh란 secure shell의 약자로 클라이언트와 서버 간의 보안 상 안전한 연결을 위한 암호화 프로토콜  예시: aws ec2 생성 시 private key를 설정하여 서버 접근 시 활용  ssh -i \u0026#34;/pwd/private-key.pem\u0026#34; user@server.host # private key 활용  기본 ssh 포트는 22 ssh 포트 변경 시 /etc/ssh/sshd_config의 설정을 변경해주자 ssh-agent, ssh-add 명령어로 ssh-agent에 private key를 저장하여 활용 가능  private key를 직접 입력하지 않고 서버 접속을 가능케 함        ssh academy","title":"리눅스 기초 명령어 top 10"},{"content":"이 문서는 유튜브 강의 AWS VPC 상세히 알아보기를 공부하며 작성한 내용을 포함합니다.\nAWS VPC는 사용자가 정의한 가상 네트워크  Region에 종속적임\n AWS VPC 구성 요소  subnet : VPC를 특정 범위로 나눔 RouteTable : 네트워크 트래픽 라우팅 테이블 Internet GW : VPC의 리소스에서 인터넷 통신을 활성하기 위한 게이트웨이 NAT GW : 네트워크 주소 변환을 통해 private subnet 에서 인터넷 통신을 연결하는 게이트웨이 VPC Endpoint : NAT, IGW 등을 통하지 않고 AWS 서비스를 비공개로 연결 가능케하는 서비스  subnet  AZ에 종속적이고 AZ는 3개 이상 사용하는 것을 권장한다고 함.\n subnet을 설정하는 best practices  AZ마다 public subnet, private subnet 생성  public subnet 들을 총괄하는 RouteTable 추가 private subnet 마다 NAT GW 추가   public subnet에는 bastion 위치 그 외 대부분 서비스는 private subnet에 위치 요즘엔 서비스 구별에 따라 private subnet을 여러 개 만들지 않는 추세라고 함 subnet 내 서비스들의 IP 를 설정하지 않도록 설계  autoscaling 등을 위함    ","permalink":"https://halimess.github.io/posts/aws/vpc/","summary":"이 문서는 유튜브 강의 AWS VPC 상세히 알아보기를 공부하며 작성한 내용을 포함합니다.\nAWS VPC는 사용자가 정의한 가상 네트워크  Region에 종속적임\n AWS VPC 구성 요소  subnet : VPC를 특정 범위로 나눔 RouteTable : 네트워크 트래픽 라우팅 테이블 Internet GW : VPC의 리소스에서 인터넷 통신을 활성하기 위한 게이트웨이 NAT GW : 네트워크 주소 변환을 통해 private subnet 에서 인터넷 통신을 연결하는 게이트웨이 VPC Endpoint : NAT, IGW 등을 통하지 않고 AWS 서비스를 비공개로 연결 가능케하는 서비스  subnet  AZ에 종속적이고 AZ는 3개 이상 사용하는 것을 권장한다고 함.","title":"AWS VPC 이론 공부"},{"content":"소개 1장. 설계와 아키텍처란? 설계랑 아키텍처는 같은 말이다.\n 아키텍처는 고수준의 무언가, 설계는 저수준의 구조 혹은 결정사항을 의미할 때가 많지만, 이러한 구분은 무의미 저수준의 세부사항과 고수준의 구조는 소프트웨어 전체 설계의 구성 요소 고수준 -\u0026gt; 저수준으로 향하는 의사결정의 연속성만이 있을 뿐  소프트웨어 아키텍처의 목표  필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화 즉, 설계 품질의 척도는 요구 사항을 만족시키는 데 드는 비용을 재는 척도  엉망진창이 되어가는 신호  시스템을 급하게 만들거나 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나 코드와 설계의 구조를 깔끔하게 만들려는 생각을 전혀하지 않으면   파국이다\u0026hellip;\n 빨리 가는 유일한 방법은 제대로 가는 것이다.\n2장. 두 가지 가치에 대한 이야기 소프트웨어 시스템의 두 가지 가치  행위 (behavior)  기계가 수익을 창출하거나 비용을 절약 개발자는  기능 명세서나 요구사항 문서를 구체화 코드를 작성 디버깅     구조 (structure)  기계의 행위를 쉽게 변경할 수 있도록 변경사항을 적용하는 데 어려움은  변경되는 범위(scope)에 비례 변경사항의 형태(shape)와는 관련이 없어야 한다      중요성과 긴급성 아이젠하워 매트릭스의 4 가지 유형\n 긴급하고 중요한 긴급하지는 않지만 중요한 긴급하지만 중요하지 않은 긴급하지도 중요하지도 않은   아키텍처는 1, 2 번에 해당 행위는 1, 3번에 해당   3번에 해당하는 행위를 첫 번째로 격상시키지 마라. 아키텍처가 후순위가 되면, 개발하는 비용이 증가하고 변경사항을 적용하는 일이 현실적으로 불가능해진다.\n기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 개발자 책임이다.\n  프로그래밍 패러다임 3장. 패러다임 개요 패러다임은 무엇을 해선 안되는지를 말한다.\n 구조적 프로그래밍 (structured programming)  goto문 ❌   객체 지향 프로그래밍 (object-oriented programming)  함수 포인터 ❌   함수형 프로그래밍 (functional programming)  할당문 ❌    세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)의 연관성에 주목하자\n4장. 구조적 프로그래밍 반증 가능한 단위로 기능적 분해하는 방법\n기능적 분해 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 모듈과 컴포넌트를 입증할 수 있는 아주 작은 기능들로 세분화 가능\nif/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조로 프로그래밍  goto문을 사용하면 모듈로 분해할 수 없는 경우가 발생 goto문을 사용하더라도 모듈로 분해할 수 있는 좋은 사용 방식은 분기와 반복의 단순한 제어 구조 대다수의 현대적 언어는 goto문을 포함하지 않음   데이크스트라는 프로그램 관점에서 유클리드 계층구조로 증명하려 했으나 끝내하지 못했다. 테스트로 프로그램의 동작을 증명할 순 없다. 다만 충분한 테스트로 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있을 뿐이다.\n 결론 모듈, 컴포넌트, 서비스를 쉽게 테스트할 수 있도록 해야 한다.\n5장. 객체 지향 프로그래밍 객체 지향의 3가지 개념? 캡슐화? (encapsulation)  객체 지향에만 국한된 건 아니다 C 프로그램의 헤더 파일을 제공하는 것으로 캡슐화된다. C++ 컴파일러는 클래스의 멤버 변수를 해당 클래스의 헤더파일에 선언해야 한다.  완전한 캡슐화가 깨짐   C++ 컴파일러는 클래스의 인스턴스 크기를 알 수 있어야 한다.\n  객체 지향 프로그래밍은 개발자가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거란 믿음을 기반한다. 실제로 객체 지향을 제공한다는 언어들은 C 언어에서 누렸던 완벽한 캡슐화를 약화시켰다.  상속? (inheritance)  객체 지향 언어가 확실히 제공했다. 상속은 단순히 어떤 변수, 함수를 하나의 유효 범위로 묶어서 재정의하는 일 이전에도 있었던 기법이나, 객체 지향 언어는 상속을 편리한 방식으로 제공  다형성? (polymorphism)  전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력 플러그인 아키텍처를 구성할 수 있다.  장치 독립적인 아키텍처 예시) 유닉스 운영 체제의 입출력 장치 드라이버  다섯 가지 표준 함수를 제공 open, close, read, write, seek   FILE 데이터 구조는 이들 다섯 함수를 가리키는 포인터를 포함한다.\n    함수 포인터의 위험성  포인터를 초기화하는 관례를 준수해야 한다 개발자가 이를 망각하면 버그가 발생하며, 이 경우 디버깅이 매우 힘들다   객체 지향 언어는 이러한 관례를 없애준다. 소스 코드 의존성은 인터페이스를 추가하여 의존성 역전시킬 수 있다  배포 독립성, 개발 독립성 확보     고수준 정책을 포함하는 모듈과 저수준의 세부사항을 포함하는 모듈의 독립성 보장\n 6장. 함수형 프로그래밍 가변 변수가 없기 때문에 동시성 애플리케이션에 마주치는 모든 문제가 생기지 않는다.\n race, deadlock, concurrent update 문제\n 가변성 분리 가변 컴포넌트와 불변(순수 함수형) 컴포넌트를 분리해야 한다\n 불변 컴포넌트를 가변 컴포넌트와 통신하게 하고, 가변 컴포넌트의 상태 변경은 트랜잭션, 재시도 등의 방법으로 concurrent update / race 문제를 예방한다. 가능한 한 많은 처리는 불변 컴포넌트로 옮기고, 가변 컴포넌트에는 가능한 한 많은 코드를 빼내야 한다.  이벤트 소싱  상태 변경이 아닌 트랜잭션을 저장 CRUD가 아닌 CR만 수행하여, 동시 업데이트 문제가 발생하지 않는다. 저장 공간이 많이 필요하다 -\u0026gt; 이젠 이러한 저장 공간은 충분히 확보할 수 있다. git과 같은 VCS가 한 예시   설계 원칙 S.O.L.I.D\n 변경에 유연 / 이해하기 쉽게 / 컴포넌트의 기반\n 7장. SRP: 단일 책임 원칙 (Single Responsibility Principle) 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.\n 서로 다른 액터(소프트웨어 사용자)가 의존하는 코드를 서로 분리 데이터와 메서드를 분리 -\u0026gt; 퍼사드 (Facade) 패턴  8장. OCP: 개방-폐쇄 원칙 (Open-Closed Principle) 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 설계\n 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 컴포넌트 단위로 분리 저수준 컴포넌트에서 발생한 변경이 고수준 컴포넌트에 영향을 끼쳐선 안된다  9장. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle) 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들어라\n 하위 타입은 상위 타입과 서로 치환 가능해야 한다\n  아키텍처 수준으로 확장해야 한다  치환 가능성을 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 한다.    10장. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle) 사용하지 않는 것에 의존하지 않아야 한다.\n 언어 종류에 따라 영향받는 정도가 다르다 필요한 것에만 의존하여 한 컴포넌트의 변경으로 다른 컴포넌트의 재컴파일과 재배포를 하지 않도록 한다.  11장. DIP: 의존성 역전 원칙 (Dependency Inversion Principle) 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다.\n 세부사항이 정책에 의존해야 한다.\n  유연성이 극대화된 시스템으로 소크 코드 의존성이 추상(abstraction)에 의존 변동성이 큰 구체적인 요소에 의존하지 않도록 설계  운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 의존하여도 용납\n  인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 설계 의존성 역전을 위해 추상 팩토리를 사용하곤 한다.   컴포넌트 원칙 12장. 컴포넌트 컴포넌트는 배포 단위로, 자바의 경우 jar 파일이 컴포넌트이다. 잘 설계된 컴포넌트는 독립적으로 배포 가능하며 독립적으로 개발 가능해야 한다.\n컴포넌트 플러그인 아키텍처\n13장. 컴포넌트 응집도  REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)  소프트웨어 재사용 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스하며 버전 번호가 같아야 한다   CCP: 공통 폐쇄 원칙 (Common Closure Principle) CRP: 공통 재사용 원칙 (Common Reuse Principle)  TBU\n","permalink":"https://halimess.github.io/posts/cleanarchitecture/","summary":"소개 1장. 설계와 아키텍처란? 설계랑 아키텍처는 같은 말이다.\n 아키텍처는 고수준의 무언가, 설계는 저수준의 구조 혹은 결정사항을 의미할 때가 많지만, 이러한 구분은 무의미 저수준의 세부사항과 고수준의 구조는 소프트웨어 전체 설계의 구성 요소 고수준 -\u0026gt; 저수준으로 향하는 의사결정의 연속성만이 있을 뿐  소프트웨어 아키텍처의 목표  필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화 즉, 설계 품질의 척도는 요구 사항을 만족시키는 데 드는 비용을 재는 척도  엉망진창이 되어가는 신호  시스템을 급하게 만들거나 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나 코드와 설계의 구조를 깔끔하게 만들려는 생각을 전혀하지 않으면   파국이다\u0026hellip;","title":"책 내용 정리: Clean Architecture"},{"content":"개발 블로그를 만들었다!\nHugo 기반에 PaperMod theme을 적용해보았다.\nHugo는 go 언어로 만들어진 정적 사이트를 쉽게 만들어 주는 도구이다. 기본 설정 이후에는 markdown으로 블로그 글을 포스팅할 수 있다.\nGithub/Gitlab Pages, Amazon S3, Heroku 등 거의 모든 배포 도구로 배포할 수 있다.\n꾸준히 작성하여 나의 개발 자산을 늘리자! 😃\n","permalink":"https://halimess.github.io/posts/firstpage/","summary":"개발 블로그를 만들었다!\nHugo 기반에 PaperMod theme을 적용해보았다.\nHugo는 go 언어로 만들어진 정적 사이트를 쉽게 만들어 주는 도구이다. 기본 설정 이후에는 markdown으로 블로그 글을 포스팅할 수 있다.\nGithub/Gitlab Pages, Amazon S3, Heroku 등 거의 모든 배포 도구로 배포할 수 있다.\n꾸준히 작성하여 나의 개발 자산을 늘리자! 😃","title":"개발 블로그 시작"}]