---
title: "책 내용 정리: Clean Architecture"
date: 2021-04-28T02:00:32+09:00
# weight: 1
# aliases: ["/first"]
tags: [
    "clean", "architecture", "book", "clean architecture",
    "pattern", "SOLID", "DI", "Facade", "Factory"
]
author: "halimess"
# author: ["Me", "You"] # multiple authors
showToc: true
TocOpen: false
draft: false
hidemeta: false
comments: false
description: "Clean Architecture 책에서 중요하다고 생각한 내용 정리"
disableHLJS: true # to disable highlightjs
disableShare: false
disableHLJS: false
hideSummary: false
searchHidden: true
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
cover:
    # image: "awsCloudPractitionerEssentials.png" # image path/url
    # alt: "AWS Cloud Practitoner Essentials" # alt text
    # caption: "aws" # display caption under cover
    relative: false # when using page bundles set this to true
    hidden: true # only hide on current single page
---

# 소개

## 1장. 설계와 아키텍처란?

설계랑 아키텍처는 같은 말이다.
* 아키텍처는 고수준의 무언가, 설계는 저수준의 구조 혹은 결정사항을 의미할 때가 많지만, 이러한 구분은 무의미
* 저수준의 세부사항과 고수준의 구조는 소프트웨어 전체 설계의 구성 요소
* 고수준 -> 저수준으로 향하는 의사결정의 연속성만이 있을 뿐


### 소프트웨어 아키텍처의 목표
* 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화
* 즉, 설계 품질의 척도는 요구 사항을 만족시키는 데 드는 비용을 재는 척도


#### 엉망진창이 되어가는 신호
1. 시스템을 급하게 만들거나
2. 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나
3. 코드와 설계의 구조를 깔끔하게 만들려는 생각을 전혀하지 않으면
> 파국이다...

**빨리 가는 유일한 방법은 제대로 가는 것이다.**


## 2장. 두 가지 가치에 대한 이야기

### 소프트웨어 시스템의 두 가지 가치
1. 행위 (behavior)
    * 기계가 수익을 창출하거나 비용을 절약
    * 개발자는
        * 기능 명세서나 요구사항 문서를 구체화
        * 코드를 작성
        * 디버깅
2. 구조 (structure)
    * 기계의 행위를 쉽게 변경할 수 있도록
    * 변경사항을 적용하는 데 어려움은
        * 변경되는 범위(scope)에 비례
        * 변경사항의 형태(shape)와는 관련이 없어야 한다

### 중요성과 긴급성
아이젠하워 매트릭스의 4 가지 유형
1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지 않은
4. 긴급하지도 중요하지도 않은

* 아키텍처는 1, 2 번에 해당
* 행위는 1, 3번에 해당
> 3번에 해당하는 행위를 첫 번째로 격상시키지 마라.
> 아키텍처가 후순위가 되면, 개발하는 비용이 증가하고 변경사항을 적용하는 일이 현실적으로 불가능해진다.
>
> **기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 개발자 책임이다.**

---

# 프로그래밍 패러다임

## 3장. 패러다임 개요
패러다임은 무엇을 해선 안되는지를 말한다.

* 구조적 프로그래밍 (structured programming)
    * goto문 ❌
* 객체 지향 프로그래밍 (object-oriented programming)
    * 함수 포인터 ❌
* 함수형 프로그래밍 (functional programming)
    * 할당문 ❌

*세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)의 연관성에 주목하자*

## 4장. 구조적 프로그래밍
반증 가능한 단위로 기능적 분해하는 방법

### 기능적 분해
대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 모듈과 컴포넌트를 입증할 수 있는 아주 작은 기능들로 세분화 가능

#### if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조로 프로그래밍
* goto문을 사용하면 모듈로 분해할 수 없는 경우가 발생
* goto문을 사용하더라도 모듈로 분해할 수 있는 좋은 사용 방식은 분기와 반복의 단순한 제어 구조
* 대다수의 현대적 언어는 goto문을 포함하지 않음

> 데이크스트라는 프로그램 관점에서 유클리드 계층구조로 증명하려 했으나 끝내하지 못했다.
> `테스트`로 프로그램의 동작을 증명할 순 없다.
> 다만 충분한 테스트로 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있을 뿐이다.

### 결론
모듈, 컴포넌트, 서비스를 쉽게 테스트할 수 있도록 해야 한다.

## 5장. 객체 지향 프로그래밍

### 객체 지향의 3가지 개념?
#### 캡슐화? (encapsulation)
* 객체 지향에만 국한된 건 아니다
* C 프로그램의 헤더 파일을 제공하는 것으로 캡슐화된다.
* C++ 컴파일러는 클래스의 멤버 변수를 해당 클래스의 헤더파일에 선언해야 한다.
    * 완전한 캡슐화가 깨짐
    > C++ 컴파일러는 클래스의 인스턴스 크기를 알 수 있어야 한다.
* 객체 지향 프로그래밍은 개발자가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거란 믿음을 기반한다.
* 실제로 객체 지향을 제공한다는 언어들은 C 언어에서 누렸던 완벽한 캡슐화를 약화시켰다.
#### 상속? (inheritance)
* 객체 지향 언어가 확실히 제공했다.
* 상속은 단순히 어떤 변수, 함수를 하나의 유효 범위로 묶어서 재정의하는 일
* 이전에도 있었던 기법이나, 객체 지향 언어는 상속을 편리한 방식으로 제공
#### 다형성? (polymorphism)
* 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
* 플러그인 아키텍처를 구성할 수 있다.
    * 장치 독립적인 아키텍처
    * 예시) 유닉스 운영 체제의 입출력 장치 드라이버
        * 다섯 가지 표준 함수를 제공
        * open, close, read, write, seek
        > FILE 데이터 구조는 이들 다섯 함수를 가리키는 포인터를 포함한다.
* 함수 포인터의 위험성
    * 포인터를 초기화하는 관례를 준수해야 한다
    * 개발자가 이를 망각하면 버그가 발생하며, 이 경우 디버깅이 매우 힘들다
* 객체 지향 언어는 이러한 관례를 없애준다.
* 소스 코드 의존성은 인터페이스를 추가하여 의존성 역전시킬 수 있다
    * 배포 독립성, 개발 독립성 확보
> 고수준 정책을 포함하는 모듈과 저수준의 세부사항을 포함하는 모듈의 독립성 보장

### 6장. 함수형 프로그래밍
가변 변수가 없기 때문에 동시성 애플리케이션에 마주치는 모든 문제가 생기지 않는다.
> race, deadlock, concurrent update 문제

#### 가변성 분리
가변 컴포넌트와 불변(순수 함수형) 컴포넌트를 분리해야 한다
* 불변 컴포넌트를 가변 컴포넌트와 통신하게 하고,
* 가변 컴포넌트의 상태 변경은 트랜잭션, 재시도 등의 방법으로 concurrent update / race 문제를 예방한다.
* 가능한 한 많은 처리는 불변 컴포넌트로 옮기고, 가변 컴포넌트에는 가능한 한 많은 코드를 빼내야 한다.

#### 이벤트 소싱
* 상태 변경이 아닌 트랜잭션을 저장
* CRUD가 아닌 CR만 수행하여, 동시 업데이트 문제가 발생하지 않는다.
* 저장 공간이 많이 필요하다 -> 이젠 이러한 저장 공간은 충분히 확보할 수 있다.
* git과 같은 VCS가 한 예시


---


# 설계 원칙
S.O.L.I.D
> 변경에 유연 / 이해하기 쉽게 / 컴포넌트의 기반

## 7장. SRP: 단일 책임 원칙 (Single Responsibility Principle)
각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

* 서로 다른 액터(소프트웨어 사용자)가 의존하는 코드를 서로 분리
* 데이터와 메서드를 분리 -> [퍼사드 (Facade) 패턴](?)

## 8장. OCP: 개방-폐쇄 원칙 (Open-Closed Principle)
기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 설계

* 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록
* 컴포넌트 단위로 분리
* 저수준 컴포넌트에서 발생한 변경이 고수준 컴포넌트에 영향을 끼쳐선 안된다

## 9장. LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)
상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들어라
> 하위 타입은 상위 타입과 서로 치환 가능해야 한다

* 아키텍처 수준으로 확장해야 한다
    * 치환 가능성을 위배하면 시스템 아키텍처가 오염되어 `상당량의 별도 메커니즘을 추가해야` 한다.

## 10장. ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)
사용하지 않는 것에 의존하지 않아야 한다.

* 언어 종류에 따라 영향받는 정도가 다르다
* 필요한 것에만 의존하여 한 컴포넌트의 변경으로 다른 컴포넌트의 재컴파일과 재배포를 하지 않도록 한다.

## 11장. DIP: 의존성 역전 원칙 (Dependency Inversion Principle)
고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다.
> 세부사항이 정책에 의존해야 한다.

* 유연성이 극대화된 시스템으로 소크 코드 의존성이 추상(abstraction)에 의존
* 변동성이 큰 구체적인 요소에 의존하지 않도록 설계
    > 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 의존하여도 용납
* 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 설계
* 의존성 역전을 위해 [추상 팩토리](?)를 사용하곤 한다.

---

# 컴포넌트 원칙

## 12장. 컴포넌트
컴포넌트는 배포 단위로, 자바의 경우 jar 파일이 컴포넌트이다.
잘 설계된 컴포넌트는 `독립적으로 배포 가능하며 독립적으로 개발 가능`해야 한다.

컴포넌트 플러그인 아키텍처

## 13장. 컴포넌트 응집도
* REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
    * 소프트웨어 재사용
    * 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함
    * 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스하며 버전 번호가 같아야 한다
* CCP: 공통 폐쇄 원칙 (Common Closure Principle)
* CRP: 공통 재사용 원칙 (Common Reuse Principle)




**TBU**